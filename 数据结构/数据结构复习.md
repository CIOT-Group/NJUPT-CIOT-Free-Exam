# 物联网特色数据结构复习

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [物联网特色数据结构复习](#物联网特色数据结构复习)
  - [考试复习要点](#考试复习要点)
  - [第一章 绪论](#第一章-绪论)
    - [1. 不同存储结构的特点和区别](#1-不同存储结构的特点和区别)
    - [2. 顺序存储和链式存储的特点和区别](#2-顺序存储和链式存储的特点和区别)
  - [第二章 线性表](#第二章-线性表)
    - [1. 线性表基本操作](#1-线性表基本操作)
    - [2. 算法思想类题目，解答时需描述细节，使其具备可实现性](#2-算法思想类题目解答时需描述细节使其具备可实现性)
    - [3. 程序题，给出代码，同样重要的还有注释；可复用书本功能代码](#3-程序题给出代码同样重要的还有注释可复用书本功能代码)
  - [第三章 堆栈和队列](#第三章-堆栈和队列)
    - [1. 栈的特点和应用](#1-栈的特点和应用)
    - [2. 典型数据结构，算法或模式在工程场景的应用举例](#2-典型数据结构算法或模式在工程场景的应用举例)
    - [3. 表达式计算](#3-表达式计算)
    - [4. 递归](#4-递归)
  - [第四章 数组和字符串](#第四章-数组和字符串)
    - [1. 数组存储](#1-数组存储)
    - [2. 压缩存储的基本原理，目的](#2-压缩存储的基本原理目的)
    - [3. 对称矩阵和三角矩阵](#3-对称矩阵和三角矩阵)
    - [4. 稀疏矩阵](#4-稀疏矩阵)
  - [第五章 树和二叉树](#第五章-树和二叉树)
    - [1. 树的基本术语](#1-树的基本术语)
    - [2. 二叉树的遍历](#2-二叉树的遍历)
    - [3. 树和森林](#3-树和森林)
    - [3. 树和森林的存储方法（复习要点上没有）](#3-树和森林的存储方法复习要点上没有)
    - [4. 树和森林的遍历（复习要点上没有）](#4-树和森林的遍历复习要点上没有)
    - [5. 堆和优先权队列](#5-堆和优先权队列)
    - [6. 哈夫曼树和哈夫曼编码，及其物理含义](#6-哈夫曼树和哈夫曼编码及其物理含义)
  - [第六章 集合和搜索](#第六章-集合和搜索)
  - [第七章 搜索树](#第七章-搜索树)
    - [1. 二叉搜索树](#1-二叉搜索树)
    - [2. 二叉平衡树（AVL 树）](#2-二叉平衡树avl-树)
    - [3. m 叉搜索树（复习要点上没有）](#3-m-叉搜索树复习要点上没有)
    - [4. B-树](#4-b-树)
  - [第八章 散列表](#第八章-散列表)
    - [1. 常见的散列函数](#1-常见的散列函数)
    - [2. 散列冲突的处理方法](#2-散列冲突的处理方法)
    - [3. 影响哈希表性能的因素分析](#3-影响哈希表性能的因素分析)
  - [第九章 图](#第九章-图)
    - [1. 图的定义和基本术语](#1-图的定义和基本术语)
    - [2. 图的存储结构](#2-图的存储结构)
    - [3. 图的遍历](#3-图的遍历)
    - [4. AOV 网和拓扑排序（复习要点上没有）](#4-aov-网和拓扑排序复习要点上没有)
    - [5. AOE 网和关键路径（复习要点上没有）](#5-aoe-网和关键路径复习要点上没有)
    - [6. 最小代价生成树](#6-最小代价生成树)
    - [7. 单元最短路径（复习要点上没有）](#7-单元最短路径复习要点上没有)
  - [第十章 排序](#第十章-排序)
    - [1. 简单选择排序](#1-简单选择排序)
    - [2. 直接插入排序](#2-直接插入排序)
    - [3. 冒泡排序](#3-冒泡排序)
    - [4. 快速排序](#4-快速排序)
    - [5. 两路合并排序](#5-两路合并排序)
    - [6. 堆排序](#6-堆排序)
  - [~~草泥马，老子终于码完了。傻逼南邮数据结构（划掉）~~](#草泥马老子终于码完了傻逼南邮数据结构划掉)

<!-- /code_chunk_output -->

## 考试复习要点

(备注：仅为要点，不涉及的未必不考)

1. 数据结构的概念，数据的逻辑结构包括哪 4 种，或者哪 2 种。数据逻辑结构和存储结构的差别。
2. 算法的定义、特点等概念算法的时空复杂度分析。
3. 理解各类典型时间复杂度，能够对其进行排序。
4. 线性表、栈、队列、环形队列、循环队列、串的基本概念和抽象数据类型，它们的异同。
5. 线性表、栈、队列、环形队列、循环队列基本操作及其实现。能够举例说明栈和队列在实际工程场景(包括但不限于软件开发，网络设计，通信系统，机械系统等)中的应用。
6. 基于线性表的算法设计(包括但不限于流程图、伪代码)、代码实现，以及设计算法的时空复杂度分析
7. 中缀表达式转换为后缀表达式，后缀表达式求值。
8. 数组存储地址计算方法，各类压缩矩阵存储的基本原理和应用
9. 树的多种表示方法有哪些，树的基本概念。
10. 树和二叉树的性质。
11. 树和二叉树的遍历。通过遍历序列，构造二叉树
12. 树、森林和二叉树的转换。
13. 哈夫曼树的构造方法(书本算法代码，以及依据该代码构造哈夫曼树)，哈夫曼编码和解码方法，哈夫曼树的性质，以及如何计算哈弗曼树的带权路径长度
14. 递归的基本概念，递归模型，以及递归思想解决问题
15. 顺序查找、二分查找(折半查找) 的基本思想、步骤、复杂度分析 (二叉判定树的构建，平均查找长度求解)，以及工程应用。
16. 二又排序树和平衡树的基本思想、步骤、复杂度分析，以及工程应用
17. 哈希冲突、哈希查找。
18. 哈希建表方法，各种处理冲突的方法
19. 哈希查找，成功和不成功时 ASL (平均查找长度)分析
20. 最小生成树算法，Prim 和 kruskal 算法，最小生成树的代价。
21. 排序算法有简单选择排序、直接插入排序、冒泡排序、快速排序、合并排序、堆排序等，掌握原理、步骤、复杂度、稳定性分析
22. 图、有向图、无向图的基本概念。
23. 图的表示方法，图的存储结构
24. 图的性质。
25. 连通图、强连通图、连通分量、强连通分量的基本概念和性质
26. 图的遍历。DFS 和 BFS 遍历的方法。遍历生成树。

## 第一章 绪论

### 1. 不同存储结构的特点和区别

逻辑结构：线性结构、树形结构、图形结构、集合结构
存储结构：顺序存储结构、链式存储结构
数据的运算：搜索，插入，删除，更新

### 2. 顺序存储和链式存储的特点和区别

**（1）存取 (读写) 方式**
顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。例如在第 $i$ 个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问 $i$ 次。

**（2）逻辑结构与物理结构**
采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置则不一定相邻，对应的逻辑关系是通过指针链接来表示的。

**（3）查找、插入和删除操作**
对于按值查找，顺序表无序时，两者的时间复杂度均为 $O(n)$；顺序表有序时，可采用折半查找，此时的时间复杂度为 $O(log_{2}n)$。对于按序号查找，顺序表支持随机访问，时间复杂度仅为 $O(1)$，而链表的平均时间复杂度为 $O(n)$。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。

**（4）空间分配**
顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存储的结点空间只在需要时申请分配，只要内存有空闻就可以分配，操作灵活、高效。

## 第二章 线性表

### 1. 线性表基本操作

（1）顺序表 **书 P10**
![Alt text](assets\image-2.png)
优点：一种随机访问的存储结构，可以快速地存取表中任一位置的元素，存储空间利用率高。
缺点：插入和删除效率低，难以临时扩大。
设第一个元素存储地址 $loc(a_{0})$，每个元素占用 k 个存储单元，则任意函数 $a_{i}$ 在内存中的存储地址为

$$
loc(a_{i}) = loc(a_{0}) + i \times k
$$

元素插入在最后时间复杂度最小，删除最后元素时间复杂度最大，插入和删除平均时间复杂度均为 $O(n)$。

（2）链表 **书 P14**
**单链表基本运算**：插入、删除、查找 **书 P16-20** 除查找定位外，时间复杂度均为常数阶。
![Alt text](assets\image-0.png)
**带表头结点的单链表**：**书 P20-21** 表头结点不存储数据，仅用于定位，表头结点的指针域存储第一个结点的地址。在插入和删除元素时不需要单独处理插入头节点之前或删除头节点的情况，从而简化运算。
![Alt text](assets\image-1.png)
**单循环链表**：**书 P21** 表尾结点的指针域指向头结点。
![Alt text](assets\image-3.png)
**双向链表**：**书 P21-22** 每个结点有两个指针域，分别指向其前驱和后继。
![Alt text](assets\image-4.png)
双向链表插入运算核心：

```cpp
q->llink = p->llink;
// 将 q 的左链接指向节点 p 的左链接，这样就将节点 q 插入到节点 p 的前面。
q->rlink = p;
// 将 q 的右链接指向节点 p，建立 q 到 p 的链接。
p->llink->rlink = q;
// 将节点 p 前一个节点的右链接指向节点 q，确保前一个节点指向新插入的节点 q。
p->llink = q;
// 最后，将节点 p 的左链接指向节点 q，完成插入操作。
```

双向链表删除运算核心：

```cpp
p->llink->rlink = p->rlink;
// 将节点 p 的前一个节点的右链接指向节点 p 的后一个节点。这样就将节点 p 从链表中断开，使得前一个节点直接连接到节点 p 的后一个节点。
p->rlink->llink = p->llink;
// 将节点 p 的后一个节点的左链接指向节点 p 的前一个节点。这样就确保了节点 p 的后一个节点正确地连接到节点 p 的前一个节点。
free p;
// 释放节点 p 所占用的内存空间，以防止内存泄漏。
```

### 2. 算法思想类题目，解答时需描述细节，使其具备可实现性

### 3. 程序题，给出代码，同样重要的还有注释；可复用书本功能代码

## 第三章 堆栈和队列

### 1. 栈的特点和应用

**（1）堆栈**
元素入栈和顺序和出栈顺序相反，具有后进先出特点。堆栈限定了插入和删除操作。
栈空条件：`top == -1`
栈满条件：`top == maxSize - 1`
进栈操作：`top++`, 将元素放在 top 处
出栈操作：`top--`, 返回 top 处元素

**（2）队列**
元素入队和顺序和出队顺序相同，具有先进先出特点。
![Alt text](assets\image-5.png)
约定 rear 总是指向队尾元素，元素进队，rear 增 1，约定 front 指向当前队中队头元素的前一位置，元素出队，front 增 1，当 rear=maxSize-1 时不能再进队。
队空条件：`front == rear`
队满条件：`rear == maxSize - 1`
元素 e 进队：`rear++; element[rear]=e`
元素 e 出队：`front++; return element[front]`
![Alt text](assets\image-6.png)
普通队列存在“假溢出”，改进方法为采用循环队列，一个首尾相连的环。
队空条件：`front == rear`
队满条件：`(rear + 1) % maxSize == front`牺牲一个元素空间
元素 e 进队：`rear = (rear + 1) % maxSize`将 e 放在 rear 处
元素 e 出队：`front = (front + 1) % maxSize`取出 front 出元素 e
![Alt text](assets\image-7.png)

### 2. 典型数据结构，算法或模式在工程场景的应用举例

**（1）栈:**
计算机科学领域应用广泛，如括号匹配，表达式求值等
**（2）队列:**
宏任务/微任务，先进先执行
后端也应用广泛，如消息队列、RabbitMQ、ActiveMQ 等，能起到延迟缓冲的功效
**（3）递归:**
生活现象:种瓜得瓜
软件开发应用:快速排序、DNS 域名解析，文件夹遍历

### 3. 表达式计算

**后缀表达式计算：**
从左到右扫描后缀表达式，遇到操作数，则将操作数压入栈中；遇到操作符，则弹出栈顶的两个操作数，进行相应的操作（栈顶元素为第一个操作数，次顶元素为第二个操作数），并将结果入栈。直到扫描结束，栈顶元素即为最终结果。
![Alt text](assets\image-8.png)
**中缀表达式转后缀表达式：**
![Alt text](assets\image-9.png)
**快速方法（逃课方法）**

```shell
# 中缀转后缀
a/(b-c)+d*e
# 1. (b-c) => [bc-]
a/[bc-]+d*e
# 2. d*e => [de*]
a/[bc-]+[de*]
# 3. a/[bc-] => [a[bc-]/]
[abc-/]+[de*]
# 4. [abc-/]+[de*] => [abc-/de*+]
abc-/de*+
```

### 4. 递归

尾递归（递归语句最后一条执行）：可以用循环语句转化为非递归
非尾递归：用栈转化为非递归
一般地，一个递归模型是由递归出口和递归体两部分组成。递归出口确定递归到何时结束，递归体确定递归求解时的递推关系。
**斐波那契数列和汉诺塔两个递归例子**

```cpp
// 计算斐波那契数列
long fib(int n)
{
    if (n == 0 || n == 2)
    {
        return 1;
    } else
    {
        return fib(n - 1) + fib(n - 2);
    }
}

// 计算汉诺塔
void hanoi(int n, char A, char B, char C)
{
    if (n == 1)
    {
        printf("Move disk 1 from %c to %c\n", A, C);
    }
    else
    {
        hanoi(n - 1, A, C, B);
        printf("Move disk %d from %c to %c\n", n, A, C);
        hanoi(n - 1, B, A, C);
    }
}
```

**递归树的构建：**
![Alt text](assets\image-10.png)

## 第四章 数组和字符串

### 1. 数组存储

（1）一维数组
下标为 $i(0 \le i \le n)$ 的数组元素 $A[i]$ 的存储地址 $loc(A[i])$ 如下，其中 $d$ 为每个元素所占的字节数。

$$
loc(A[i]) = loc(A[0]) + i \times d \space (0 \le i < n)
$$

（2）二维数组 $A[m][n]$
**行优先存储**:

$$
\begin{bmatrix}
 b[0][0] & b[0][1] \\
 b[1][0] & b[1][1] \\
 b[2][0] & b[2][1]
\end{bmatrix}
=> b[0][0], b[0][1], b[1][0], b[1][1], b[2][0], b[2][1]
$$

数组元素 $A[i][j]$ 的存储地址 $loc(A[i][j])$ 如下，其中 $d$ 为每个元素所占的字节数。

$$
loc(A[i][j]) = loc(A[0][0]) + (i \times n + j) \times d \space (0 \le i < m, 0 \le j < n)
$$

**列优先存储**:

$$
\begin{bmatrix}
 b[0][0] & b[0][1] \\
 b[1][0] & b[1][1] \\
 b[2][0] & b[2][1]
\end{bmatrix}
=> b[0][0], b[1][0], b[2][0], b[0][1], b[1][1], b[2][1]
$$

数组元素 $A[i][j]$ 的存储地址 $loc(A[i][j])$ 如下，其中 $d$ 为每个元素所占的字节数。

$$
loc(A[i][j]) = loc(A[0][0]) + (j \times m + i) \times d \space (0 \le i < m, 0 \le j < n)
$$

(3)n 维数组 $A[m_{1}][m_{2}]\dots[m_{n}]$
数组元素 $A[i_{1}][i_{2}]\dots[i_{n}]$ 的存储地址 $loc(A[i_{1}][i_{2}]\dots[i_{n}])$ 如下，其中 $d$ 为每个元素所占的字节数。

$$
loc(A[i_{1}][i_{2}]\dots[i_{n}]) = loc(A[0][0]\dots[0]) + \\
(i_{1} \times m_{2} \times m_{3} \times \dots \times m_{n} + \\
i_{2} \times m_{3} \times \dots \times m_{n} + \\
\dots + \\
i_{n}) \times d
$$

### 2. 压缩存储的基本原理，目的

在实际应用中，矩阵规模通常很大，为了节约空间，加快矩阵运算速度,需要对矩阵进行压缩。压缩存储的核心思想包括:

1. 对于值相同的多个矩阵元素，只为其中一个元素分配存储空间
2. 值为零的矩阵元素尽量不分配空间
3. 可实现无损解压，即矩阵中所有未分配存储空间的元素可以被完全恢复

### 3. 对称矩阵和三角矩阵

**对称矩阵 $A[n][n]$**：

（1）以行优先规则存储下三角元素（包括对角线元素），矩阵元素 $a_{ij}$ 在一维数组 B 中下标 $k(0 \le k < N)$ 满足以下公式：

$$
\begin{bmatrix}
 a_{00} &  &  & \\
 a_{10} & a_{11} &  & \\
 a_{20} & a_{21} & a_{22} & \\
 a_{30} & a_{31} & a_{32} & a_{33}
\end{bmatrix}
\space k = \begin{cases}
\frac{i \times (i + 1)}{2} + j ,\space i\ge j \\
\frac{j \times (j + 1)}{2} + i ,\space i < j
\end{cases}
$$

（2）以行优先规则存储上三角元素（包括对角线元素），矩阵元素 $a_{ij}$ 在一维数组 B 中下标 $k(0 \le k < N)$ 满足以下公式：

$$
\begin{bmatrix}
 a_{00} & a_{10} & a_{20} & a_{30} \\
 & a_{11} & a_{21} & a_{31} \\
 &  & a_{22} & a_{32} \\
 &  &  & a_{33}
\end{bmatrix}
\space k = \begin{cases}
\frac{j \times (2n - j - 1)}{2} + i ,\space i > j \\
\frac{i \times (2n - i - 1)}{2} + j ,\space i \le j
\end{cases}
$$

（3）以列优先规则存储下三角元素（包括对角线元素），矩阵元素 $a_{ij}$ 在一维数组 B 中下标 $k(0 \le k < N)$ 满足以下公式：

$$
\begin{bmatrix}
 a_{00} &  &  & \\
 a_{10} & a_{11} &  & \\
 a_{20} & a_{21} & a_{22} & \\
 a_{30} & a_{31} & a_{32} & a_{33}
\end{bmatrix}
\space k = \begin{cases}
\frac{j \times (j + 1)}{2} + i ,\space i \ge j \\
\frac{i \times (i + 1)}{2} + j ,\space i < j
\end{cases}
$$

（4）以列优先规则存储上三角元素（包括对角线元素），矩阵元素 $a_{ij}$ 在一维数组 B 中下标 $k(0 \le k < N)$ 满足以下公式：

$$
\begin{bmatrix}
 a_{00} & a_{10} & a_{20} & a_{30} \\
 & a_{11} & a_{21} & a_{31} \\
 &  & a_{22} & a_{32} \\
 &  &  & a_{33}
\end{bmatrix}
\space k = \begin{cases}
\frac{i \times (2n - i - 1)}{2} + j ,\space i > j \\
\frac{j \times (2n - j - 1)}{2} + i ,\space i \le j
\end{cases}
$$

**三角矩阵 $A[n][n]$**：

（1）下三角矩阵以行优先规则存储元素 $a_{ij}$ 在一维数组 B 中下标 $k(0 \le k < N)$ 满足以下公式：

$$
\begin{bmatrix}
 a_{00} & c & c & c\\
 a_{10} & a_{11} & c & c\\
 a_{20} & a_{21} & a_{22} & c\\
 a_{30} & a_{31} & a_{32} & a_{33}
\end{bmatrix}
\space k = \begin{cases}
\frac{i \times (i + 1)}{2} + j ,\space i\ge j \\
N,\space i < j
\end{cases}
$$

（2）上三角矩阵以行优先规则存储元素 $a_{ij}$ 在一维数组 B 中下标 $k(0 \le k < N)$ 满足以下公式：

$$
\begin{bmatrix}
 a_{00} & a_{10} & a_{20} & a_{30} \\
 c & a_{11} & a_{21} & a_{31} \\
 c & c & a_{22} & a_{32} \\
 c & c & c & a_{33}
\end{bmatrix}
\space k = \begin{cases}
N,\space i > j \\
\frac{i \times (2n - i - 1)}{2} + j ,\space i \le j
\end{cases}
$$

### 4. 稀疏矩阵

**稀疏矩阵 $A[n][n]$**：
稀疏矩阵存储方法：三元组

```cpp
int m, n, t; // 行数，列数，非零元素个数
Term table[MAXSIZE]; // 存储三元组
```

![Alt text](assets\image-11.png)
**稀疏矩阵转置方法**
**（1）方法一**
步骤 1：依次访问 A 的行三元组表中各个三元组 $<i, j, a_{ij}>$，交换元素行列号后依次保存到 B 的行三元组表中。时间复杂度：$O(t)$，t 为非零元个数
步骤 2：将 B 的行三元组表中的行三元组按照行下标值从小到大重新排序。时间复杂度：与排序算法有关
![Alt text](assets\image-12.png)
**（2）方法二**
步骤 1：对 A 的行三元组表进行第 1 次扫描，找到列下标 $i=0$ 的所有三元组 $<i, 0, a_{i0}>$，交换元素行列号后依次保存到 B 的行三元组表中。
步骤 2：对 A 的行三元组表进行第 2 次扫描，找到列下标 $i=1$ 的所有三元组 $<i, 1, a_{i1}>$，交换元素行列号后依次保存到 B 的行三元组表中。
……
步骤 n：对 A 的行三元组表进行第 n 次扫描，找到列下标 $i=n-1$ 的所有三元组 $<i, n-1, a_{i,n-1}>$，交换元素行列号后依次保存到 B 的行三元组表中。
时间复杂度：$O(n \times t)$
![Alt text](assets\image-13.png)
![Alt text](assets\image-14.png)
![Alt text](assets\image-15.png)
![Alt text](assets\image-16.png)
**（3）方法三:稀疏矩阵的快速转置算法**
借助辅助数组 num 和 k，长度均为 n（稀疏矩阵 A 的列数）。
数组 num 中元素 num[j]统计矩阵 A 中列号为 j 的非零元素个数。
数组 k 中元素 k[j]记录矩阵 A 中列号从 0 到 j-1 的非零元素个数总和，也表示 j 列第一个非零元素在转置后的矩阵 B 的行三元组表中的位置。
快速转置矩阵时间复杂度：$O(n+t)$，t 为非零元个数

```cpp
    ////数组num的元素统计稀疏矩阵A列号为j的非零元素个数
    int num[maxSize];
    // 数组k的元素k[j]统计稀疏矩阵A中列号从0到j-1的非零元素个数总和，该值也表示j列第一个非零元素在转置稀疏矩阵B的行三元组表中的位置
    int k[maxSize];

    // 计算每一列非零元素个数
    for (int j = 0; j < A.n; j++)
        num[j] = 0;
    for (int i = 0; i < A.t; i++)
        num[A.Table[i].col]++;

    // 计算每一列非零元素在B矩阵中的位置
    for (int j = 0; j < A.n; j++)
        k[j] = 0;
    for (int j = 1; j < A.n; j++)
        k[j] = k[j - 1] + num[j - 1];

    // 借助数组k完成快速转置
    for (int i = 0; i < A.t; i++)
    {
        int index = k[A.Table[i].col]++;
        B.Table[index].col = A.Table[i].row;
        B.Table[index].row = A.Table[i].col;
        B.Table[index].value = A.Table[i].value;
    }
```

▲ 接下来的转置方法比较抽象，一切均为个人理解记忆方法，具体看书 P59，假设三元组表有 8 列，分别标号 0，1，2，3，4，5，6，7，则：
第一步：按照下述方法计算数组 k
![Alt text](assets\image-17.png)
![Alt text](assets\image-18.png)
第二步：写出辅助数组 k

```shell
index    0   1   2   3   4   5
  k      0   2   3   5   7   7
```

借助辅助数组 k，从上到下依次遍历三元组表，先看 A 数组中第 0 行的 j 元素为 0，对照辅助数组 k，当序号（index）为 0 时，k 的值为 0，那么将数组 A 第 0 行 i 和 j 元素交换位置，然后填入转置后的数组 B 的第 0 行，最后将数组 k 序号为 0 对应的值+1，得到如下的辅助数组：

```shell
index    0   1   2   3   4   5
  k     [1]  2   3   5   7   7
```

然后看 A 数组中第 1 行的 j 元素为 3，对照辅助数组 k，当序号（index）为 3 时，k 的值为 5，那么将数组 A 第 1 行 i 和 j 元素交换位置，然后填入转置后的数组 B 的第 5 行，最后将数组 k 序号为 3 对应的值+1，得到如下的辅助数组：

```shell
index    0   1   2   3   4   5
  k      1   2   3  [6]  7   7
```

然后看 A 数组中第 2 行的 j 元素为 5，对照辅助数组 k，当序号（index）为 5 时，k 的值为 7，那么将数组 A 第 2 行 i 和 j 元素交换位置，然后填入转置后的数组 B 的第 7 行，最后将数组 k 序号为 5 对应的值+1，得到如下的辅助数组：

```shell
index    0   1   2   3   4   5
  k      1   2   3   6   7  [8]
```

以此类推：看 A 数组中第 m 行的 j 元素为 a，对照辅助数组 k，当序号（index）为 a 时，k 的值为 b，那么将数组 A 第 m 行 i 和 j 元素交换位置，然后填入转置后的数组 B 的第 b 行，最后将数组 k 序号为 a 对应的值+1，得到辅助数组。

重复上述过程，直到转置结束。

## 第五章 树和二叉树

### 1. 树的基本术语

结点、路径、双亲、孩子、兄弟、后裔、祖先、结点的度、叶子、分支节点、树的度、结点的层次、树的高度、无序树、有序树、森林 **书 P71-72**

**二叉树的性质**
（1）二叉树的第 $i(i \ge 1)$ 层上的结点数最多为 $2^{i-1}$ 个。
（2）高度为 $h$ 的二叉树最多有 $2^h-1$ 个结点。
（3）高度为 $h$ 的二叉树中结点总数最多为 $2^h-1$ 个。
（4）包含 $n$ 个结点的二叉树高度至少为 $\left \lceil log_2(n+1) \right \rceil $，最高为 $n$。
（5）任意一颗二叉树中，若叶子结点数量为$m$，度为 2 的结点数量为$n$，则 $m=n+1$。
（6）高度为 $h$ 的二叉树恰好有$2^h-1$ 个结点时称为满二叉树。
（7）满二叉树从右到左依序去掉 1 个或多个最底部的结点成为完全二叉树。
（8）不存在度为 1 的结点的二叉树称为扩充二叉树，又称为 2-树。
（9）具有 n 个结点的完全二叉树的高度为 $\left \lceil log_2(n+1) \right \rceil $。
![Alt text](assets\image-19.png)
**二叉树的存储**
（1）完全二叉树的顺序存储表示
结点按从上到下、从左到右，逐层顺序存储于一块连续的存储单元(即数组)
根结点存储在下标为 0 的位置，其他结点按上述性质中的编号规则依次顺序存储
（2）二叉树的链接表示
n 个结点有 2n 个指针域，分支数为 n-1，非空指针域有 n-1 个，空指针域个数 = 2n-(n-1) = n+1
![Alt text](assets\image-20.png)

### 2. 二叉树的遍历

（1）先序遍历(VLR)
先访问根结点，再先序遍历左子树，最后先序遍历右子树
（2）中序遍历(LVR)
先中序遍历左子树，再访问根结点，最后中序遍历右子树
（3）后序遍历(LRV)
先后序遍历左子树，最后后序遍历右子树，再访问根结点
（4）层次遍历
从根结点开始，从上到下，从左到右访问结点
![Alt text](assets\image-21.png)
四种遍历算法的时间渐进复杂度均为 $O(n)$，n 为节点数量

```cpp
// 假设有一颗树如下，分别进行四种遍历
            A
          /   \
        D       B
      /           \
    E               C
  /   \           /
H       F       K
      /   \
    J       G

// 先序遍历
A D E H F J G B C K
// 中序遍历
H E J F G D A B K C
// 后序遍历
H J G F E D K C B A
// 层次遍历
A D B E C H F K J G

// 先序遍历实现
void PreOrderTree(BinaryTree* bt)
{
    PreOrder(bt->root);
}
void PreOrder(BTNode* t)
{
    if(t == NULL) return;
    printf("%c ",t->data);  //访问根节点
    PreOrder(t->lchild);    //先序遍历左子树
    PreOrder(t->rchild);    //先序遍历右子树
}
// 中序遍历实现
void InOrderTree(BinaryTree* bt)
{
    InOrder(bt->root);
}
void InOrder(BTNode* t)
{
    if(t == NULL) return;
    InOrder(t->lchild);      //中序遍历左子树
    printf("%c ",t->data);   //访问根节点
    InOrder(t->rchild);      //中序遍历右子树
}
// 后序遍历实现
void PostOrderTree(BinaryTree* bt)
{
    PostOrder(bt->root);
}
void PostOrder(BTNode* t)
{
    if(t == NULL) return;
    PostOrder(t->lchild);    //后序遍历左子树
    PostOrder(t->rchild);    //后序遍历右子树
    printf("%c ",t->data);   //访问根节点
}
// 层次遍历实现
#define QUEUESIZE 100
void LevelOrderTree(BinaryTree* tree)
{
    if (!tree -> root) return;
    Queue Q;    //创建队列
    Create(&Q, QUEUESIZE);
    BTNode *p = tree -> root;
    EnQueue(&Q, p);     //根节点入队
    while (!IsEmpty(Q))
    {
        Front(&Q, p);
        DeQueue(&Q);
        printf("%c ", p -> data);
        if (p -> lchild)
            EnQueue(&Q, p -> lchild);
        if (p -> rchild)
            EnQueue(&Q, p -> rchild);
    }
    Destroy(&Q);
}
```

已知先序和中序，可以唯一确定二叉树
已知后序和中序，可以唯一确定二叉树
若 $n>1$，已知先序和后序，无法唯一确定二叉树

### 3. 树和森林

**（1）树转换成二叉树**
转换步骤：
连线：将树中具有兄弟关系的结点从左到右依次连线；
去线：对于树中的每个结点，仅保留与其最左(即第一个)孩子的连线，去掉该结点到其余孩子的所有连线；
整形：调整为标准形状的二叉树（根结点+左子树+右叉树）。
性质：将一棵树转换生成二叉树，则生成的二叉树的根结点一定没有右子树
![Alt text](assets\image-22.png)
**（2）二叉树转换为树或森林**
转换步骤：
整形：将二叉树中的所有结点的左孩子连线调整为垂直形态、右孩子连线调整为水平形态；
连线：对于任一水平线上的结点，将该水平线上的第一个结点的父节点，与该水平线上的其他结点进行连线；
去线：去除所有的水平连线，即删除原二叉树中各结点与其右孩子的连线；
整形：调整步骤 3 结束之后的树的形状，使其符合树的一般特征要求（父子、兄弟关系清晰）。
![Alt text](assets\image-25.png)
![Alt text](assets\image-23.png)
![Alt text](assets\image-24.png)

### 3. 树和森林的存储方法（复习要点上没有）

**（1）基于链接结构的存储表示方法**
多重链表表示法
![Alt text](assets\image-26.png)
孩子兄弟表示法
![Alt text](assets\image-27.png)
三重链表表示法
![Alt text](assets\image-28.png)
**（2）基于顺序结构的存储表示方法**
**双亲表示法**
在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。
在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二又树中各结点之间的关系。
二叉树都可以用树的存储结构来存储，但树却不都能用二叉树的存储结构来存储。
![Alt text](assets\image-29.png)
**带右链的先序表示法**
存储顺序：按照对应的二叉树的先序遍历的顺序存储
结点结构：

- sibling 存储兄弟结点的位置下标
- element 存储数据元素
- lTag 标识孩子结点位置的状态量
  - ITag = 0，表示后继结点即为当前结点的孩子
  - ITag = 1，表示当前结点不存在任何孩子结点

![Alt text](assets\image-30.png)

### 4. 树和森林的遍历（复习要点上没有）

按深度方向的遍历
（1）先根遍历
若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树相应二叉树的先序序列相同
（2）后根遍历
若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同。

```shell
    D
  / | \
E   F   G
|   |
H   J
# 先根遍历序列
D E H F G J
# 后根遍历序列
H E J F G D
```

森林的遍历方法
（1）先序遍历
对森林的先序遍历等于对每棵树先根遍历的简单拼接
![Alt text](assets\image-31.png)
（2）中序遍历
对森林的中序遍历等于对每棵树后根遍历的简单拼接
![Alt text](assets\image-32.png)
（3）后序遍历
森林的后序遍历并不等于其每棵树后根遍历的简单拼接
![Alt text](assets\image-33.png)
（4）宽度遍历
首先按照从左到右的顺序，依次访问森林的树中处于第一层的结点;然后按照同样的顺序，依次访问处于第二层中的的结点;再访问第三层...等，最后访问最下层的结点。
![Alt text](assets\image-34.png)

### 5. 堆和优先权队列

**（1）堆**
最小堆：树中每个结点的数据都小于或等于其孩子结点，因此，在最小堆中，堆顶存储的数据是整棵树中最小的;
最大堆：树中每个结点的数据都大于或等于其孩子结点，因此，在最大堆中，堆顶存储的数据是整棵树中最大的。
堆的逻辑结构是完全二叉树，所以可以使用顺序存储结构来存储堆。
![Alt text](assets\image-35.png)
**（2）向下调整和建堆运算**
~~算法思想:从最后一个叶子的双亲反方向直到根结点，依次对其中的每一个结点执行向下调整 (AdiustDown)操作，步骤如下：
步骤 1：若该结点小于或等于其最小的孩子，则本轮向下调整结束;否则执行步骤 2
步骤 2：将该结点与最小孩子交换，交换完成后，继续以该结点为考查对象，再次执行步骤 1~~
**直！接！看！例！子！**
![Alt text](assets\image-36.png)
**（3）优先权队列**
优先权队列一种具有如下特性的数据结构:元素加入数据结构的次序无关紧要，但每次从该数据结构中取元素时，都只取具有最高优先级的元素这样的数据结构即为优先权队列
**高效方案：**基于堆的实现方法
进队：将新元素放在堆尾元素后面，并按照最小堆 (或最大堆) 进行适当调整，向上调整(AdjustUp)$O(log_{2}n)$
出队：直接取出堆顶元素即可，$O(1)$，取出后，按照最小堆(或最大堆) 进行适当调整，$O(log_{2}n)$
**算法思想**
设新元素插入在最小堆的元素序列的尾部
从新插入元素开始，自底向上，与父结点元素进行大小比较: 若父结点元素大于孩子结点元素，则进行交换调整，直到其父节点元素不大于孩子结点元素，或者新元素已到达堆顶位置为止。
![Alt text](assets\image-37.png)
取出堆顶元素
将堆顶元素赋值给 x，然后用堆底元素替代当前堆顶元素，同时让堆的大小减小 1，最后调用 AdjustDown

### 6. 哈夫曼树和哈夫曼编码，及其物理含义

结点的路径长度：从根结点到该结点的路径上所包括的边的数目
树的内路径长度：除叶结点外，从根到树中其他所有结点的路径长度之和
![Alt text](assets\image-38.png)
树的外路径长度：从根到树中所有结点的路径长度之和
![Alt text](assets\image-39.png)
叶结点的加权路径长度：设叶结点是带权的，则叶结点的加权路径长度是其路径长度与权值的乘积
树的加权路径长度：所有叶结点的加权路径长度之和，记为 WPL

$$
WPL=\sum_{k=1}^{m} w_{k} \times l_{k}
$$

其中，$m$ 是叶结点的数量，$w_{k}$,是第个叶结点的权值，$l_{k}$ 是该叶结点的路径长度
具有最小带权路径长度的二叉树称为哈夫曼树(也称最优树)
![Alt text](assets\image-40.png)

**哈夫曼树和哈夫曼算法：**
算法思想：

1. 根据给定的一组权值 ${w_{1},w_{2},…,w_{n}}$，构造一个森林 $F={T_{1},T_{2},…,T_{n}}$，其中， $T_{i}∈F$ 只包含一个根结点，权值为 $w_{i}$。
2. 从 F 中选取根结点权值最小的两棵树，不妨设为 $T_{i}$ 和 $T_{j}$；然后对 $T_{i}$ 和 $T_{j}$ 进行合并处理，生成新的树，新树根的左、右子树即为 $T_{i}$ 和 $T_{j}$（一般约定其中树根权值较小的作为左子树），新树根的权值为 $T_{i}$ 和 $T_{j}$ 的根结点的权值之和；最后再将生成的新二叉树加入 F。
3. 若 F 中包含的二叉树数量超过 1 棵，则转步骤 2 继续执行；否则，算法结束，F 包含的唯一的一棵二叉树即为最终生成的哈夫曼树。

![Alt text](assets\image-41.png)

**哈夫曼编码**
在从哈夫曼树的每个结点到其左孩子的边上标记 0，到其右孩子的边上标记 1。
权值越大的字符编码越短。
![Alt text](assets\image-42.png)
![Alt text](assets\image-43.png)

## 第六章 集合和搜索

集合的基本概念：滚！去！学！数！学！
平均搜索长度：给定值与集合中元素的关键字值的平均比较次数称为平均搜索程度 ASL
**（1）顺序搜索**
顺序搜索无序表：$ASL_{\text{成功}} = \frac{n+1}{2}$, $ASL_{\text{失败}} = n$
顺序搜索有序表：$ASL_{\text{成功}} = \frac{n+1}{2}$, $ASL_{\text{失败}} = \frac{n}{2} + 2$
**（2）对半搜索 书 P112-113 的例子很好**
要求：线性表是有序表，采用顺序存储结构
![Alt text](assets\image-44.png)
![Alt text](assets\image-45.png)
![Alt text](assets\image-46.png)
![Alt text](assets\image-47.png)
![Alt text](assets\image-48.png)
**（3）二叉判定树**
任意结点左右子树上结点个数差=1，左右子树高度差最多为 1，一棵树的高度为 $\left \lfloor log_{2}n \right \rfloor +1$
**二叉判定树的构造**

1. 根结点为首次选取的分割点 r，分割点 r 将表 T 分为左表与右表
2. 在左表中选取分割点 s 作为上一个分割点 r 的左孩子，分割点 s 将表 T 分为左表与右表，继续步骤（2）直到左表与右表为空
3. 在右表中选取分割点 s 作为上一个分割点 r 的右孩子，分割点 s 将表 T 分为左表与右表，继续步骤（3）直到左表与右表为空

![Alt text](assets\image-49.png)
二叉判定树的 ASL 计算：直接看例题
![Alt text](assets\image-50.png)
![Alt text](assets\image-51.png)

## 第七章 搜索树

### 1. 二叉搜索树

（1）定义：
设结点由关键字值表征，假定所有结点的关键字值各不相同，二又搜索树或者是一棵空二又树或者是具有下列性质的二叉树:

- 若左子树不空，则左子树上所有结点的关键字值均小于根结点关键字值:
- 若右子树不空，则右子树上所有结点的关键字值均大于根结点关键字值:
- 左、右子树也分别是二又搜索树

（2）性质：
若以中序遍历一棵二叉搜索树，将得到一个以关键字值递增排列的有序序列

（3）查找：
在一棵二又搜索树上，查找关键字为 k 的元素

- 若二叉树为空，则搜索失败。
- 否则，将 k 与根结点比较
  - 若 k 小于该结点的关键字，则以同样的方法搜索左子树，而不必搜索右子树
  - 若 k 大于该结点的关键字，则以同样的方法搜索右子树，而不必搜索左子树
  - 若 k 等于该结点的关键字，则搜索成功终止。

（4）插入

- 查找插入元素 x 的位置。尝试自根结点相下搜索 x，搜索失败的位置处作为 x 的插入位置
- 生成新结点。构造一个新结点 p 存放新元素 x
- 插入新结点。新结点连至双亲结点 q，成为 q 的孩子。至于 p 是 q 的左孩子还是右孩子，这取决于 x 与 q 关键字值的大小。如果原二又搜索树是空树，则新结点 p 成为新二又搜索树的根。
  ![Alt text](assets\image-52.png)

（5）删除
删除仅有一个孩子的结点：
将待删除结点的双亲结点中指向待删除结点的指针，指向待删除结点非空的孩子，释放待删除结点
删除有两个孩子的结点：
选择待删除结点在中序遍历序列下的直接前驱或后继代替待删除节点
删除重复的代替者。代替者没有孩子：直接删除；代替者有一个孩子: 孩子直接代替后删除
![Alt text](assets\image-53.png)

（6）平均搜索长度计算
直接看例题，先补全搜索失败的结点，再进行计算
![Alt text](assets\image-54.png)

### 2. 二叉平衡树（AVL 树）

（1）性质
根的左、右子树高度之差的绝对值不超过 1
根的左、右子树都是二叉平衡树
（2）结点的平衡因子
结点平衡因子被定义为该结点的左子树高度减去右子树高度之差
（3）平衡调整的基本原则
第一步：找到需要调整的最小子树
第二步：调整最小子树的平衡性
最小子树的根结点 s 即为离新插入结点最近且平衡因子绝对值超过 1 的祖先结点。也就是插入后由新结点回溯至根结点的路径上第一个出现的非平衡结点。
（4）插入
按照二叉搜索树的插入方式插入新元素
判断插入新元素后的二叉平衡树其平衡性是否被破坏，如果平衡性没有破坏，则插入运算结束
如果平衡性被破坏，根据新结点在最小子树 s 上的插入类型来选择不同的平衡
调整方法：

- 如果属于 LL(RR)插入类型，即新结点插入 s 的左(右)子树的左(右)子树上，则采用单旋转方法
  ![Alt text](assets\image-55.png)
- 如果属于 LR(RL)插入类型，即新结点插入 s 的左(右)子树的右(左)子树上，则采用双旋转方法
  ![Alt text](assets\image-56.png)
  ![Alt text](assets\image-57.png)

~~（5）删除（复习要点上没有）~~
在平衡二叉树中删除一个结点与二叉搜索树（二叉排序树、二叉查找树）中删除结点类似，只是增加了调整这一步骤。

其过程如下：

- 查找。先在平衡二叉树中查找到关键字为 k 的结点 p。
- 删除。删除 p 结点分以下几种情况
  - 叶子结点：直接删除该结点。
  - 单分支（一个孩子）结点：用 p 结点的左或右孩子结点替代 p 结点(结点替换)。
  - 双分支（2 个孩子）结点：用 p 结点的中序前驱(或中序后继)结点 q 的值替换 p 结点的值。再删除结点 q。
- 调整。
  若被删除的是结点 q，则从结点 q 向根结点方向查找第一个失去平衡的结点：
- ① 若所有结点都是平衡的，则不需要调整。
- ② 假设找到某个结点的平衡因子为-2：
  - 其右孩子的平衡因子是-1，则作 RR 型调整﹔
  - 其右孩子的平衡因子是 1，则作 RL 型调整；
  - 其右孩子的平衡因子是 0，则作 RR 或 RL 型调整均可。
- ③ 假设找到某个结点的平衡因子为 2：
  - 其左孩子的平衡因子是-1，则作 LR 型调整；
  - 其左孩子的平衡因子是 1，则作 LL 型调整；
  - 其左孩子的平衡因子是 0，则作 LR 或 LL 型调整均可。

（6）时间复杂度
最好情况和一般情况：$O(log_{2}n)$
最坏情况：单支树，$O(n)$

### 3. m 叉搜索树（复习要点上没有）

![Alt text](assets\image-58.png)
从定义中可以得到：

- 一个 m 叉搜索树的结点中，最多存放 m-1 个元素和 m 个指向子树的指针；
- 每个结点中包含的元素个数比它包含的指针数少 1。

为什么要有 m 叉树？
内搜索：当集合足够小，可以驻留在内存中时，相应的搜索方法称为内搜索。
外搜索：如果文件很大，以至于计算机内存容不下时，它们必须存放在外存中。在外存中搜索给定关键字值的元素的方法称为外搜索。
内存中集合用二叉平衡树表示。外存中，集合可以用一种特殊的 m 叉搜索树：B-树来表示。
设法减少磁盘存取操作的次数是外搜索算法设计应充分考虑的问题。

m 叉树的性质：见 **书 P129-130**

### 4. B-树

（1）定义
一棵 m 阶 B-树是一棵 m 叉搜索树，它或者是空树，或者是满足下列特性的树：

- 根结点至少有两个孩子（根结点可以只有一个元素）
- 除根结点和失败结点外的所有结点至少有 $\left \lceil \frac{m}{2} \right \rceil $ 个孩子。（保证 B-树不会退化成单支树）
- 所有失败结点均在同一层上。（考虑平衡性）
  $$
  \left \lceil \frac{m}{2} \right \rceil  - 1 \le \text{每个结点中关键字数目} \le m - 1
  $$

（2）性质

- 设 B-树失败结点的总数是 s，那么，一棵 B-树包含的元素总数 N 是 B-树的失败结点的总数 s 减 1，即：N = s – 1。
- 含有 N 个元素的 m 阶 B-树的高度 h 有：$h \le 1 + log_{\left \lceil \frac{m}{2} \right \rceil} \frac{N + 1}{2}$

（3）搜索
B-树上进行搜索的过程是一个顺指针查找结点，和在结点的关键字中搜索交叉进行的过程。
第一步：在 B-树中找结点，需执行的磁盘访问次数最多是 $h \le 1 + log_{\left \lceil \frac{m}{2} \right \rceil} \frac{N + 1}{2}$
第二步：在结点中找关键字，B-树的每个结点可以看成一个有序表，在一个 B-树结点中搜索是在内存中的搜索，因此可以采用顺序搜索和二分搜索等内搜索算法进行。

（4）插入（建议看 ppt 动画来学）
B 树插入操作的步骤：

- Step 1：搜索。在 B-树中搜索给定关键字值的元素。如果搜索成功，表示有重复元素，则插入运算结束；否则转 Step 2 将新元素插入搜索失败结点上一层处的叶子结点 q 中。
- Step 2：插入。将新元素和一个空指针插入结点 q 中。如果插入后，结点 q 未上溢出，即结点中包含的元素个数未超过 m-1（指针数未超过 m），则插入运算结束。否则转 Step 3 进行结点
  的分裂操作。
- Step 3: 分裂。以 $\left \lceil \frac{m}{2} \right \rceil $ 处的元素为分割点，将上溢出结点一分为三，然后将分割点元素和新结点
  （第 $\left \lceil \frac{m}{2} \right \rceil + 1$ 个位置至第 m 个位置的元素形成的结点）插入双亲结点中。继续检查此双亲结点的上溢出问题。如果没有上溢出，则插入运算结束，否则转 Step 3 继续该双亲结点的分裂操作，直至不再产生上溢出现象。
- Tips：如果按照 Step 3，根结点产生分裂，由于根结点没有双亲，那么分裂产生的两个结点的指针以及分割点元素将组成一个新的根结点，从而将导致 B-树长高一层。
  ![Alt text](assets\image-59.png)

（5）删除（建议看 ppt 动画来学）
B-树删除运算的步骤：

- Step 1：搜索。在 B-树中搜索给定关键字值的元素。如果搜素不成功，则删除运算结束。否则转 Step 2 执行元素的删除操作。
- Step 2：删除。首先判断删除类型，根据删除类型选用相应的删除方法：
  如果属于情形 1，即被删除的元素在叶子结点中，则转 Step 3 执行从叶子结点中删除该元素的操作；
  如果属于情形 2，即被删除的元素不在叶子结点中，则用该元素右侧子树上的最小元素取代它，从而将问题转化为情形 1，然后转 Step 3 执行从叶子结点中删除该元素的操作。
- Step 3：从叶子结点中删除元素。首先从叶子结点中直接删除该元素，如果删除元素后没有下溢(小于 $\left \lceil \frac{m}{2} \right \rceil - 1$ 个)，则删除运算结束。 否则首先考虑采用“借” 的方法处理下溢出，如果左右两侧兄弟结点都没有富余，则采用“并”的方法处理下溢出，然后继续检查其双亲结点的下溢出问题。如果没有下溢出，则删除运算结束，否则继续该双亲结点的先“借”后“并”操作，直至不再有下溢出现象产生。
- Tips：如果由于“并”操作，导致根结点中的一个元素被删除，并且该结点只包含一个元素，则根结点成为不包含任何元素的空结点，此时 B-树将变矮一层。
  ![Alt text](assets\image-60.png)

## 第八章 散列表

哈希表是一种存储结构，它并非适合任何情况，主要适合记录的关键字与存储地址存在某种函数关系的数据
散列函数(h, hash)：集合元素的关键字(key)与其存储位置(Loc)之间的关系函数，散列函数计算出的值也称为散列值
Loc(key)：表示关键字值为 key 的集合元素的存储地址
散列表(hash table, 哈希表)：用散列函数建立起来的表，用于存储集合元素

### 1. 常见的散列函数

什么是好的散列函数？
确定性：同一值总被映射到同一地址
快速：散列函数的计算尽量简单
满射：尽可能充分覆盖整个散列表存储空间
均分布：为了充分利用散列空间和降低冲突，要使映射到各个位置的概率接近，避免很多元素扎堆聚集的现象。

（1）除留取余法
![Alt text](assets\image-61.png)
（2）除留余数法的改进 MAD
![Alt text](assets\image-62.png)
（3）平方取中法
![Alt text](assets\image-63.png)
（4）折叠法

1. 把关键字值自左到右，分成位数相等的几部分；每部分位数与散列表地址位数相同，最后一部分的位数可以短些。
2. 把这些部分的数据叠加起来，得到该关键字的散列地址。
   ![Alt text](assets\image-64.png)

（5）数字分析法
![Alt text](assets\image-65.png)

### 2. 散列冲突的处理方法

（1）拉链法（开散列法）

- 元素在单链表上按照关键字有序排列，则单链表上的查找操作等价于有序表的顺序搜索。如果元素在单链表上有序，则可以提前结束查找，并在查找失败处插入新结点
- 元素在单链表上无序排列，则单链表上的查找操作等价于无序表的顺序搜索。如果元素在单链表上无序排列，则必须先遍历链表上所有结点才能确定不重复
- 散列表中已存储集合元素个数与散列表长的比例 n/M，也称为散列表的装填因子（装填因子可以大于 1）。装填因子暗示了散列表装满的程度，也表示执行查找等操作所需比较次数。可通过设置装填因子的上限，来保证散列表的快速搜索，如超过上限则散列表需扩充。

集合元素的查找操作：

- 计算散列值 h(key)，到散列表 h(key)位置处取出单链表头指针，遍历链表进行查找：比较 key

集合元素的插入操作：

- 执行元素查找操作，查找不成功，创建新结点，执行单链表结点插入操作

平均时间复杂度分析：

- 查找操作：O(n/M)；插入操作：O(n/M)；删除操作：O(n/M)
  ![Alt text](assets\image-66.png)
  ![Alt text](assets\image-67.png)
  ![Alt text](assets\image-68.png)

优点：

- 拉链法处理冲突简单，且无聚集现象，因此平均查找长度较短；由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；

缺点：

- 指针需要额外的存储空间，当数据元素占存储空间较小时，空间使用率低

（2）开地址法（闭散列法）
对散列表插入新元素的方法：

- 从 h(key)开始，按照某种规定的次序探查允许插入新元素的空位置，基位置：h(key)
- 如果 h(key)已经被占用，需要有一种解决冲突的策略来确定如何探查下一个空位置
- 不同探查策略产生不同探索路径，依次被探索的位置称为探查序列

**线性探查法**
插入元素时，从 h(key)开始，若被占用，检查 h(key)+1，若也占用，再检查探测序列中的下个位置，直到某个位置为空时，将关键字插入该位置。若遇到散列尾部，则循环到前部继续探查。
![Alt text](assets\image-69.png)
**搜索：**
基本思想：从基位置 h(key)开始，按照线性探查序列查找元素
搜索成功：找到关键字值为 key 的元素
搜索失败：1. 遇到一个空位置；2. 探查到 h(key)前一个位置（表满）
![Alt text](assets\image-70.png)
![Alt text](assets\image-71.png)
![Alt text](assets\image-72.png)
![Alt text](assets\image-73.png)
**删除：**
为每个位置增加标志域 empty，表示该位置是否使用过。删除元素时，不改变标志位，仍为 false，元素值改为 NeverUsed
删除元素的方法：
首先搜索该元素，若搜索成功，则置该位置值为 NU，但 empty 域不作更改！
![Alt text](assets\image-74.png)
**改进的散列表搜索操作：**
改进算法：从基位置 h(key)开始，按照线性探查序列查找元素。
搜索成功：找到关键字值为 key 的元素；
搜索失败：1. 遇到一个从未使用过的空位置（`empty[i]=TRUE`）；2. 回到 h(key)（表满）
![Alt text](assets\image-75.png)
![Alt text](assets\image-76.png)
**改进的散列表插入操作:**
搜索，若搜索结果为存在重复元素则插入失败
如果搜索不到，但是表已满，则插入失败
如果搜索不到，线性探查第一个值为`NeverUsed`的位置， 插入新元素，并将`empty`设为 F
**线性探查法的缺点：**
很快表中所有位置的 empty 都变成 F
易使元素在表中连成一片（线性聚集），探查次数增加，影响搜索效率
改进方法：1. 二次探查法；2. 双散列法

**二次探查法和双散列法**
我赌他不考，比较复杂，令人头秃。
**书 P147-149** 想看的翻书看（书上只有一丢丢，反正我是不想学，考到就认命了）摆烂（（（

### 3. 影响哈希表性能的因素分析

从散列表的查找过程可见:

1. 虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需要以平均查找长度作为衡量散列表的查找效率的度量。
2. 散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。散列表的装填因子一般记为 $\alpha $，定义为一个表的装满程度，即
   $$
   \alpha = \frac{\text{表中记录数}n}{\text{散列表长度}m}
   $$
3. 散列表的平均查找长度依赖于散列表的装填因子 $\alpha $，而不直接依赖于 $n$ 或 $m$。直观地看，$\alpha $ 越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。

## 第九章 图

### 1. 图的定义和基本术语

**不会的给我学离散数学去！！！**
邻接、顶点的度、入度和出度、路径和路径长度、自回路和多重图、完全图、子图、连通图和连通分量、强连通图和强连通分量、权和网、邻接矩阵。**看书 P152-155**

### 2. 图的存储结构

（1）邻接矩阵（只放一张图，学离散数学去）
![Alt text](assets\image-77.png)
优点：

1. 便于判断两个顶点之间是否有边，即根据 `A[u][v] = 0` 或 `1` 来判断；
2. 便于计算各个顶点的度：
   对于无向图，邻接矩阵第 i 行元素之和就是顶点 i 的度
   对于有向图，第 i 行元素之和就是顶点 i 的出度；第 i 列元素之和就是顶点 i 的入度。
3. 缺点：
   不便于统计边的数目。需要扫描邻接矩阵所有元素才能统计，时间复杂度为 $O(n^2)$;
   空间复杂度高。无论是有向图还是无向图，其空间复杂度均为 $O(n^2)$。

（2）邻接表
用 n 个单链表代替邻接矩阵中的 n 行；
图中每个顶点对应邻接表中的一个单链表；
![Alt text](assets\image-78.png)
在邻接表中：
对图中每个顶点建立一个单链表，把与该顶点相邻接的顶点放在这个链表中；
每个单链表的第一个结点存放有关顶点的信息，称为单链表的头结点；其余结点存放有关边的信息，称为边结点。
因此，邻接表便由两部分组成：头结点表和边链表
![Alt text](assets\image-79.png)
如果是网的邻接表则使用带权的边结点，增加一个权值域（Weight）即可
![Alt text](assets\image-80.png)
![Alt text](assets\image-81.png)
在具体实现时，为简便起见，我们并不需要定义头结点，而仅需定义边结点即可。我们可以将头节点表简单地视为一个一维指针数组，该数组中存储的数据类型为指向边结点地址的指针。

优点：

- 便于统计边的数目。按头结点表顺序扫描所有边链表即可得到边的数目，时间复杂度为 O(n+e);
- 空间效率高。无论是有向图还是无向图，其空间复杂度均为 O(n+e)，适合于表示稀疏图。对于稠密图，考虑到邻接表中需附加存储链域，通常还是采用邻接矩阵表示法。

缺点：

- 不便于判断顶点之间是否有边。要判断 u 和 v 之间是否有边，需扫描第 u 个边链表，最坏情况下要耗费 O(n)时间；
- 不便于计算有向图各个顶点的度。在有向图的邻接表中，顶点 u 的出度是第 u 个边链表中的边结点个数，顶点 u 的入度则需遍历所有顶点的边链表。

### 3. 图的遍历

**（1）深度优先遍历(DFS)，类似先序遍历**
![Alt text](assets\image-82.png)
很抽象对不对？直接看例题，其实很简单
![Alt text](assets\image-83.png)
![Alt text](assets\image-84.png)

深度优先搜索(DFS)算法：
Step 1: 从任给的起始顶点 v 出发，访问顶点 v 并打上标记；
Step 2: 依序（顶点 v 所对应的边链表中边结点的顺序）从 v 的未被访问过的邻接点出发，深度优先搜索该图。

图的深度优先搜索遍历算法：
Step 1: 初始化标记数组；
Step 2: 依序（顶点编号）检查图中每一个顶点，如果该顶点未被访问，则调用深度优先搜索（DFS）算法以该顶点为起始点遍历该图，直至图中所有顶点都被访问过。

算法时间复杂度分析：

- 深度优先搜索算法每嵌套调用一次，实际上是对一个顶点 v 察看其所有的邻接点，并对其中未标记的邻接点嵌套调用 DFS 函数。
- 深度优先搜索遍历算法对有向图的每条边只查看 1 次，而对于无向图，查看 2 次。
- n 个顶点、e 条边的图采用邻接表存储，DFS 遍历算法的时间复杂度为 $O(n+e)$,而采用邻接矩阵存储时，时间复杂度则为 $O(n^2)$。

**（2）宽度优先遍历(BFS)，类似层次遍历**
实施过程为：

1. 首先从图中某个顶点 v 出发，访问 v;
2. 然后依次访问 v 的各个未访问过的邻接点；
3. 接着再分别从这些邻接点出发依次访问它们的未访问过的邻接点。重复步骤（3），直至图中所有已被访问的顶点的邻接点都被访问到。
   ![Alt text](assets\image-85.png)

宽度优先搜索(BFS)算法：
Step 1: 初始化队列；
Step 2: 从顶点 v 出发，访问 v 并打上标记，然后将 v 入队；
Step 3: 只要队列不空，则重复下列操作：
队首顶点 u 出队；依序（顶点 u 所对应的边链表中边结点的序）搜素 u 的未被访问过的邻接点，访问并将其入队。

图的宽度优先搜索遍历算法：
Step 1: 初始化标记数组；
Step 2: 依序（顶点编号）检查图中每一个顶点，如果该顶点未被访问，则调用宽度优先搜索算法 以该顶点为起始点遍历该图，直至图中所有顶点都被访问过。

算法时间复杂度分析：

- BFS 遍历过程中每个顶点进出队列各一次；
- 对于每个出队的顶点，都要检查其所有的邻接点，对于无向图每条边被检查 2 次；
- n 个顶点、e 条边的图采用邻接表存储，BFS 遍历算法的时间复杂度为 $O(n+e)$，而采用邻接矩阵表示，时间复杂度为 $O(n^2)$。

![Alt text](assets\image-86.png)

### 4. AOV 网和拓扑排序（复习要点上没有）

**（1）AOV 网和拓扑排序的概念**
AOV 网应该是一个有向无环图（ Directed Acycline Graph, 简称 DAG 图）
判断的方法是对有向图的顶点进行拓扑排序，若网中所有顶点都在它的拓扑序列中，则该 AOV 网必定不存在环。
拓扑排序就是将 AOV 网中所有顶点排成一个线性序列，该序列满足：若在 AOV 网中顶点 i 到顶点 j 有一条路径，则在该线性序列中的顶点 i 必定在 j 之前。

**（2）拓扑排序**
拓扑排序的过程：

1. 在图中找一个入度为零的顶点将其输出；
2. 从图中删除该顶点及其所有出边；
3. 重复(1)、(2)，直到所有顶点都输出（此时得到的序列即为拓扑序列），或图中剩下的顶点再也没有入度为零的顶点(此时存在有向回路)为止。
   ![Alt text](assets\image-87.png)

在拓扑排序过程中，需注意以下两点：

1. 从图中删除一个顶点及其所有出边时，会产生新的入度为 0 的顶点；
2. 入度为 0 的顶点的输出次序无关紧要。
   因此算法实现时，可以用堆栈或队列保存新产生的入度为 0 的顶点；

算法步骤：

1. 求出各顶点的入度存于 InDegree 数组中，并将入度为零的顶点进栈；
   （1.1）初始化 InDegree 数组；
   （1.2）依序（顶点编号）检查顶点 𝒗𝒊 所对应边链表中的每一个边结点（即顶点 𝒗𝒊 的邻接点），并将这些边结点的入度加 1。
2. 若栈不空，则重复以下操作：
   （2.1）将栈顶顶点 𝒊 出栈并保存在拓扑序列数组 topo 中；
   （2.2）将顶点 𝒊 的所有邻接点的入度减 1，若此时某个邻接点的入度为 0，便将该邻接点进栈；
3. 如果图中还有顶点未输出，则表明图中有环，无法进行拓扑排序，否则拓扑排序成功，输出序列即为拓扑序列。
4. 对有 n 个顶点、e 条边的有向图而言，拓扑排序算法的总的时间复杂度为 $O(n+e)$。

### 5. AOE 网和关键路径（复习要点上没有）

**（1）AOE 网和关键路径的概念**
AOE 网是一个带权的有向无环图，其中顶点表示事件或状态，有向边表示活动，边权表示一项活动持续的时间。
通常，AOE 网可以用来估算一项工程的完成时间。
AOE 网在正常（无环）情况下：只有一个入度为零的点，称作源点，表示整个工程开始；也只有一个出度为零的点，称作汇点，表示整个工程结束。
完成工程所需的最短时间是从开始顶点到完成顶点的最长路径的长度。这条最长路径称为关键路径。
关键路径上的边代表的活动称为关键活动。
![Alt text](assets\image-88.png)
**（2）事件相关的两个基本概念**
![Alt text](assets\image-89.png)
**（3）关键路径**
关键路径求解过程（太复杂了，我赌他不考，摆烂）**参考 书 P168-171**
![Alt text](assets\image-90.png)
![Alt text](assets\image-91.png)
![Alt text](assets\image-92.png)
![Alt text](assets\image-93.png)
![Alt text](assets\image-94.png)
![Alt text](assets\image-95.png)
![Alt text](assets\image-96.png)
对有 n 个顶点、e 条边的有向图而言：

- 调用拓扑排序算法的时间复杂度为 O(n+e)；
  求每个事件的最早和最迟发生时间，以及活动的最早和最迟开始时间，都要对所有顶点及每个顶点边链表- 中所有的边结点进行检查，其时间复杂度为 O(n+e)；
- 因此，关键路径算法的总的时间复杂度为 O(n+e)。

### 6. 最小代价生成树

一个无向连通图的生成树是一个极小连通子图，它包括图中全部顶点，并且有尽可能少的边。遍历一个连通图得到图的一棵生成树。图的生成树不是唯一的，采用不同的遍历方法，从不同的顶点出发可能得到不同的生成树。对于带权的连通图（网），寻找一棵生成树使得各条边上的权值之和最小，这棵树即为最小代价生成树。

**（1）Prim 算法（普里姆算法）**
普里姆算法构造最小代价生成树的过程：**（此处强烈建议看 PPT 的动画，会很好理解）**
假设 G=(V,E)是含有 n 个顶点的带权连通图，T=(V’,E’)是正在构造中的生成树。初始状态下，T 只有一个任意选定的起始顶点，没有边。

1. 从初始状态开始，重复执行下列运算：
   (1) 从 T 的所有入边中找一条代价最小的边 e
   (2) 将边 e 及其不属于 T 的那个顶点加入 T
   (3) 重复(1)和(2)直到所有的顶点均加入 T 为止
2. 至此，得到 G 的一棵包含 n-1 条边的最小代价生成树 T
   ![Alt text](assets\image-97.png)

实现普里姆算法：
算法步骤：
（1）初始化数组 `nearest[]`、`lowcost[]`和 `mark[]`;
（2）将初始顶点 u 加入生成树 T;
（3）循环 n-1 次，重复执行以下操作：

- 更新未入选生成树 T 的顶点对应的 `lowcost` 值和 `nearest` 值；
- 从当前尚未入选生成树 T 的顶点中，选出 `lowcost` 最小的顶点 k;
- 将 k 加入生成树 T 中；

算法时间复杂度：
对有 n 个顶点、e 条边的图而言，其算法时间复杂度为 $O(n^2)$。

**（2）Kruskal 算法（克鲁斯卡尔算法）**
克鲁斯卡尔算法的过程：**（此处强烈建议看 PPT 的动画，会很好理解）**
假设 G=(V,E)是含有 n 个顶点的带权连通图，T=(V’,E’)是正在构造中的生成树（未构成之前为由若干棵自由树组成的生成森林）。初始状态下，T 只包含 G 中的所有顶点，没有边；

- 从初始状态开始，重复执行下列运算：

1. 在 E 中选择一条代价最小的边(u,v)，并将其从 E 中删除；
2. 若在生成树的边集合 E’中加入边(u,v)以后未形成回路，则将其加进 E’中，否则继续从
3. E 中选择下一条边；
   重复执行步骤（2），直至 E’中包含 n-1 条边时为止。

- 至此，得到 G 的一棵包含 n-1 条边的最小代价生成树 T。
  ![Alt text](assets\image-98.png)

实现克鲁斯卡尔算法
算法步骤：
（1）从邻接矩阵中获取所有边存储于 `edgeSet`；
（2）调用排序函数对数组 `edgeSet` 中的边按权值从小到大排序；
（3）依次查看数组 `edgeSet` 中的边，循环执行以下操作：

- 从排序好的 `edgeSet`中取出一条边(u,v)；
- 在 `vexSet[]`数组中查找 u 和 v 所在连通分量的值 `vexSet[u]`和 `vexSet[v]`，进行判断：
  - 若 `vexSet[u]`和 `vexSet[v]`不相等，表示两顶点属于不同连通分量，输出此边，合并 `vexSet[u]`和 `vexSet[v]`两个连通分量；
  - 若 `vexSet[u]`和 `vexSet[v]`相等，表示两顶点属于同一连通分量，舍去此边而选择下一条权值最小的边。

算法时间复杂度：
对有 n 个顶点、e 条边的无向图而言：克鲁斯卡尔算法的时间复杂度为 $O(e \cdot log_{2}e)$。

### 7. 单元最短路径（复习要点上没有）

最短路径是指路径长度最短，也就是说路径上边的权值之和最小
一种最常见的最短路径算法是求单源最短路径的迪杰斯特拉（Djikstra）算法

**迪杰斯特拉（Djikstra）算法（此处强烈建议看 PPT 的动画，会很好理解）**
设 G=(V，E)是一个带权有向图， 把图中顶点集合 V 分成两组：

- 第 1 组(S)为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，以后每求得一条最短路径 v，… ，u，就将 u 加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了）。
- 第 2 组(T)为其余未求出最短路径的顶点集合（用 T 表示）。

1. 初始化：S 只包含源点即 S={v}，v 的最短路径为 0。T 包含除 v 外的其他顶点，T 中顶点 i 距离为边上的权值（若 v 与 i 有边 <v, i> ）或 ∞（若 i 不是 v 的出边邻接点）。
2. 从 T 中选取一个距离 v 最小的顶点 u，把 u 加入 S 中（该选定的距离就是 v -> u 的最短路径长度）。
3. 以 u 为新考虑的中间点，修改 T 中各顶点 j 的最短路径长度：若从源点 v 到顶点 j（j∈T）的最短路径长度（经过顶点 u）比原来最短路径长度（不经过顶点 u）短，则修改顶点 j 的最短路径长度。
4. 重复步骤（2）和（3）直到所有顶点都包含在 S 中。

- 一维数组 d：`d[i]`保存从原点到顶点 i 的最短路径长度，若原点到顶点 i 有边，则 `d[i]`的初值为边的权值，否则 `d[i]=∞`
- 一维数组 path：`path[i]`保存从原点到顶点 i 的当前最短路径上顶点 i 的直接前驱顶点的序号，若无直接前驱，则 `path[i]=-1`
- 迪杰斯特拉（Djikstra）算法时间复杂度为 $O(n^{2})$

![Alt text](assets\image-99.png)
![Alt text](assets\image-100.png)

## 第十章 排序

**一些概念**
待排序序列中两个元素 i 和 j ，i 排在 j 之前，且 i = j 排序后，i 仍然排在 j 之前，则称所用的排序算法是稳定的反之，称该排序算法是不稳定的。一个需要具有稳定性排序算法的实例-稀疏矩阵转置。
如果待排序元素总数相对于内存而言较小，整个排序过程可以在内存中进行，则称之为内部排序，简称内排序；反之，如果待排序元素总数较多，不能全部放入内存，排序过程中需访问外存，则称之为外部排序，简称外排序。
**相当重要的一张图：**
![Alt text](assets\image-101.png)

### 1. 简单选择排序

算法思想：**无序区选出最小，放最前面**
每一趟排序，找到待排序序列中关键字最小的数据元素将其与待排序序列中第一个数据元素交换位置并将其从下一趟待排序序列中移出。重复该过程，直到某趟排序时待排序序列中仅剩下两个数据元素。
![Alt text](assets\image-102.png)
稳定性：不稳定
排序趟数：$n-1$
时间复杂度：最好，最坏，平均情况均为 $O(n^{2})$
空间复杂度：最好，最坏，平均情况均为 $O(1)$
实现代码：

```cpp
// 在startIndex至表尾范围内找到最小关键字元素下标
int FindMin(List list, int startIndex)
{
    int i, minIndex = startIndex;
    for (i = startIndex + 1; i < list.n; i++)
    {
        if (list.D[i].key < list.D[minIndex].key)
            minIndex = i;
    }
    return minIndex;
}
// 交换顺序表中两个元素位置
void Swap(Entry *D, int i, int j)
{
    Entry temp;
    if (i == j)
        return;
    temp = *(D + i);
    *(D + i) = *(D + j);
    *(D + j) = temp;
}
void SelectSort(List *list)
{
    int minIndex, startIndex = 0;
    while (startIndex < list->n - 1)
    {
        minIndex = FindMin(*list, startIndex);
        Swap(list->D, startIndex, minIndex);
        startIndex++;
    }
}
```

### 2. 直接插入排序

算法思想：**无序区逐个扫描插入有序区**
从只包含一个数据元素的有序序列开始，不断地将待排序数据元素有序地插入这个有序序列中，直到有序序列包含了所有待排序数据元素为止。
![Alt text](assets\image-103.png)
稳定性：稳定
排序趟数：$n-1$
时间复杂度：最好情况-顺序 $O(n)$，最坏情况-逆序，平均情况为 $O(n^{2})$
空间复杂度：最好，最坏，平均情况均为 $O(1)$
实现代码：

```cpp
void InsertSort(List *list)
{
    int i, j;         // i标识待插入元素下标
    Entry insertItem; // 每一趟待插入元素
    for (i = 1; i < list->n; i++)
    {
        insertItem = list->D[i];     // i处元素放到临时变量中，1次移动
        for (j = i - 1; j >= 0; j--) // 不断将有序序列中元素向后移动，为待插入元素空出一个位置
        {
            if (insertItem.key < list->D[j].key)
                list->D[j + 1] = list->D[j]; // 多次比较和移动，小于号保证稳定性
            else
                break;
        }
        list->D[j + 1] = insertItem; // 待插入元素有序存放至有序序列中，1次移动
    }
}
```

### 3. 冒泡排序

算法思想：**无序区两两比较逆序交换**
从前向后不断交换相邻逆序（关键字递减）数据元素，重复该过程，直到任意相邻数据元素都不再逆序排列为止。
![Alt text](assets\image-104.png)
稳定性：稳定
排序终止条件：

1. 某趟排序未发生元素交换(`isSwap = False`)
2. 当前排序范围内只剩下两个数据元素(`i == 1`)

时间复杂度：最好情况-顺序 $O(n)$，最坏情况，平均情况为 $O(n^{2})$
空间复杂度：最好，最坏，平均情况均为 $O(1)$
实现代码：

```cpp
void BubbleSort(List *list)
{
    int i, j; // i标识每趟排序范围最后一个元素下标，每趟排序元素下标范围是0 ~ i
    for (i = list->n - 1; i > 0; i--)
    {
        BOOL isSwap = FALSE; // 标记一趟排序中是否发生了元素交换 for(j=0; j<i; j++)
        {
            if (list->D[j].key > list->D[j + 1].key) // 大于号保证稳定性
            {
                Swap(list->D, j, j + 1);
                isSwap = TRUE;
            }
        }
        if (!isSwap)
            break; // 如果本趟排序没有发生元素交换，排序完成
    }
}
```

### 4. 快速排序

算法思想：

1. 待排序序列中元素数量小于等于 1 时，无须排序，直接退出。
2. 选择分割元素 Ds (关键字为 Ks)，将序列划分成左右子序列，满足：左子序列中所有元素的关键字均不大于 Ks；右子序列中所有元素的关键字均不小于 Ks
3. 快速排序 (左子序列)
4. 快速排序 (右子序列)

准备工作：

1. low 指向待排序列的最左元素，high 指向待排序序列的最右元素
2. 选择待排序列中第一个元素 `D[low]`为分割元素
3. 游动标识 i 和 j，初始时 `i = low`，`j = high + 1`

一趟快排操作：**（此处强烈建议看 PPT 的动画）**

1. i = i + 1，从左向右扫描序列，找到第一个 ≤ 分割元素的元素后停止
2. j = j - 1，从右向左扫描序列，找到第一个 ≥ 分割元素的元素后停止
3. 如果 i < j，将 D[i] 与 D[j] 交换，继续步骤 1 和 2
4. 如果 i ≥ j，将 D[low] 与 D[i] 交换，本快速排序结束

![Alt text](assets\image-105.png)
![Alt text](assets\image-106.png)
稳定性：不稳定
时间复杂度：最好和平均情况为 $O(n \times log_{2}n)$，最坏情况-顺序 $O(n^2)$
空间复杂度：最好和平均情况为 $O(log_{2}n)$，最坏情况-顺序 $O(n)$
![Alt text](assets\image-107.png)
实现代码：

```cpp
// 序列划分方法
int Partition(List *list, int low, int high)
{
    int i = low, j = high + 1;
    Entry pivot = list->D[low]; // pivot是分割元素
    do
    {
        i++;
        while (list->D[i].key < pivot.key && i <= high)
            ; // i前进
        do
            j--;
        while (list->D[j].key > pivot.key && j >= low); // j前进
        if (i < j)
            Swap(list->D, i, j);
    } while (i < j);
    Swap(list->D, low, j);
    return j; // 此时j是分割元素下标
}
// 快速排序方法
void QuickSort(List *list, int low, int high)
{
    int k;
    if (low < high) // 当前待排序序列至少包含两个元素
    {
        k = Partition(list, low, high);
        QuickSort(list, low, k);
        QuickSort(list, k + 1, high);
    }
}
void QuickSort(List *list)
{
    QuickSort(list, 0, list->n - 1);
}
```

### 5. 两路合并排序

算法思想：
初始时将待排序的 n 个数据元素看作 n 个待合并有序序列，每个序列中只包含一个数据元素。将每 m 个待合并序列合并成一个大的有序序列。在最后一次合并中，序列个数可能少于 m。重复合并过程，直到所有数据元素都属于同一个有序序列为止。当 m = 2 时，上述合并排序过程称为两路合并（归并）排序算法。
![Alt text](assets\image-108.png)
![Alt text](assets\image-109.png)
![Alt text](assets\image-110.png)
稳定性：稳定
排序趟数：$N = \left \lceil log_{2}n \right \rceil $
时间复杂度：最好，最坏，平均时间复杂度均为：$O(n \times log\_{2}n)$
空间复杂度：最好，最坏，平均时间复杂度均为 $O(n)$
实现代码：

```cpp
// n1和n2是两个子序列长度，low是第一个子序列第一个元素下标
void Merge(List *list, Entry *temp, int low, int n1, int n2)
{
    int i = low, j = low + n1; // i,j初始时分别指向两个序列的第一个元素
    while (i <= low + n1 - 1 && j <= low + n1 + n2 - 1)
    {
        if (list->D[i].key <= list->D[j].key)
            *temp++ = list->D[i++];
        else
            *temp++ = list->D[j++];
    }
    while (i <= low + n1 - 1)
        *temp++ = list->D[i++]; // 剩余元素直接复制到temp
    while (j <= low + n1 + n2 - 1)
        *temp++ = list->D[j++]; // 剩余元素直接复制到temp
}

void MergeSort(List *list)
{
    Entry temp[MaxSize];
    int low, n1, n2, i, size = 1;
    while (size < list->n)
    {
        low = 0;                     // low是一对待合并序列中第一个序列的第一个元素下标
        while (low + size < list->n) // low + size < list->n说明至少存在两个子序列需要合并
        {
            n1 = size;
            if (low + size * 2 < list->n)
                n2 = size; // 计算第二个序列长度
            else
                n2 = list->n - low - size;
            Merge(list, temp + low, low, n1, n2);
            low += n1 + n2; // 确定下一对待合并序列中第一个序列的第一个元素下标
        }
        for (i = 0; i < low; i++)
            list->D[i] = temp[i]; // 复制一趟合并排序结果
        size *= 2;                // 子序列长度翻倍
    }
}
```

### 6. 堆排序

算法思想：
借助堆数据结构，不断输出当前堆顶元素。每次堆顶离开当前堆后，对剩余元素重新调整成堆，直到堆中只剩下一个元素。元素的输出序列可转换成元素的有序序列。
![Alt text](assets\image-111.png)
![Alt text](assets\image-112.png)
![Alt text](assets\image-113.png)
稳定性：不稳定
排序趟数：n-1
时间复杂度：最好，最坏，平均时间复杂度均为：$O(n \times log\_{2}n)$
空间复杂度：最好，最坏，平均时间复杂度均为：$O(1)$
实现代码：

```cpp
typedef struct maxheap // 定义最大堆结构体
{
    int n, MaxSize;
    Entry D[MaxSize];
} MaxHeap;
void HeapSort(MaxHeap *hp)
{
    int i;
    Entry temp;
    for (i = hp->(n - 2) / 2; i >= 0; i--)
        AdjustDown(hp->D, i, hp->n - 1);
    for (i = hp->n - 1; i > 0; i--) // i指向当前堆的堆底元素
    {
        Swap(heap->D, 0, i); // 交换堆底和堆顶元素
        AdjustDown(hp->D, 0, i - 1);
    }
}
```

## ~~草泥马，老子终于码完了。傻逼南邮数据结构（划掉）~~
